<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CQRS on Ninja Snacks</title><link>https://the.fringe.ninja/tags/cqrs/</link><description>Recent content in CQRS on Ninja Snacks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 03 Apr 2014 15:27:21 -0500</lastBuildDate><atom:link href="https://the.fringe.ninja/tags/cqrs/index.xml" rel="self" type="application/rss+xml"/><item><title>Incomplete Commands</title><link>https://the.fringe.ninja/2014/04/03/incomplete-commands/</link><pubDate>Thu, 03 Apr 2014 15:27:21 -0500</pubDate><guid>https://the.fringe.ninja/2014/04/03/incomplete-commands/</guid><description>Recently a question came up in the CQRS chatroom on Jabbr:Â  Here&amp;rsquo;s the situation. New command comes in, They can sometimes be missing some info (for daft reasons), if it is missing info then I need to call off to an external api to get the info back. This external api is unreliable so it would be better to supply the information upfront if possible.
There are a couple of ways to do this.</description></item><item><title>The Electroweak Vacuum is Eventually Consistent</title><link>https://the.fringe.ninja/2013/12/18/the-electroweak-vacuum-is-eventually-consistent/</link><pubDate>Wed, 18 Dec 2013 07:24:06 +0200</pubDate><guid>https://the.fringe.ninja/2013/12/18/the-electroweak-vacuum-is-eventually-consistent/</guid><description>The fastest information can ever travel is 3*10^8 m/s - in a vacuum. It&amp;rsquo;s 2/3rds that in a copper wire. In the ideal case.
Imagine two observers in the milky way galaxy, one at Terminus and the other at Star&amp;rsquo;s End. They will observe events from all over the universe at different times - they will not agree on the order of events. What they can agree on is that eventually they will see all of them.</description></item><item><title>CQRS - erm OOP and Validations</title><link>https://the.fringe.ninja/2013/07/10/cqrs-erm-oop-and-validations/</link><pubDate>Wed, 10 Jul 2013 21:42:12 -0700</pubDate><guid>https://the.fringe.ninja/2013/07/10/cqrs-erm-oop-and-validations/</guid><description>A discussion came up recently on the DDD/CQRS forums recently, that got sidetracked into &amp;lsquo;where do the validations go&amp;rsquo; (along with a lot of weird nonsense about async command queues, http status code pedantry, etc, but we&amp;rsquo;ll leave that for some other time). A large minority of developers - perhaps even a majority - seem to think that validations belong somewhere in the &amp;lsquo;trusted&amp;rsquo; client.
I find this conclusion strange, as none of the .</description></item><item><title>Unlocking the Key in Navision So We Can Apply CQRS</title><link>https://the.fringe.ninja/2013/06/23/unlocking-the-key-in-navision-so-we-can-apply-cqrs/</link><pubDate>Sun, 23 Jun 2013 14:46:11 -0700</pubDate><guid>https://the.fringe.ninja/2013/06/23/unlocking-the-key-in-navision-so-we-can-apply-cqrs/</guid><description>The Soap Box Part We&amp;rsquo;ve heard this before, but it bears repeating: CQRS is not just for greenfield event-sourced ddd systems. It can apply to crappy brownfield systems too. It may even have more relevance there.
Let&amp;rsquo;s take the penultimate brownfield system, an ERP system. In particular, Navision. Navision has a fantastic interface for interacting with it (snipped for brevity):
public interface SalesPrice_Port { Read_Result Read(Read request); ReadMultiple_Result ReadMultiple(ReadMultiple request); Create_Result Create(Create request); Update_Result Update(Update request); Delete_Result Delete(Delete request); } In other words, a 100% behavior free SQL-like interface that isn&amp;rsquo;t sql because you have Create / Read instead of INSERT / SELECT.</description></item></channel></rss>